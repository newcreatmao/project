[toc]

### 第一节：复杂度

##### 基本定理

一：若存在正常数c与n~0~，当N>=n~0~时，T（N）<=c*f（N），则计为T（N）=O（f（N））

例如：T（n）=n^2^+n+111,则时间复杂度为T（N）=O（n^2^)，O为上界

二：若存在正常数c和n~0~，使得N>=n~0~时，T（N）>=c*f（N），则记为T（N）=欧（f（N））

欧为下界

一般只考虑上下界

三：若存在正常数c~1~，c~2~和n~0~，使得N>=n~0~,c~1~f(N)<=T(N)<=c~2~f(N),则记为T（N）=角（f（N））

若T（N）=O（N），T（N）=欧（f（N）），则T（N）=角（f（N））

##### 推论

1. 若T~1~（N）=O(f(N))且T~2~=O（g（N）），则T~1~+T~2~=max（O(f(N)),O(g(N))),T~1~*T~2~=O(f(N)*g(N))

2. 若T（N）是一个k次多项式，则T（N）=角（N^k^）

   

##### 时间复杂度

O（1）<O(log^n^)<O(n)<O(nlog~n~)<O(n^2^)<O(n^3^)<O(2^n^)<O(n!)<O(n^n^)

1. 算出运行时间函数
2. 简化
3. 用1代替常数，修改后保留最高阶项，可忽略其系数

##### 空间复杂度

申请内存，公式与时间复杂度差不多，可与时间复杂度互换

### 第二节：线性表

定义：由零个（空表）或多个数据元素组成的有限数列，并列

a~n-2~    前驱元素    a~n~     后继元素     a~n+2~

```my.c
initlist(*l)//built a empty list
listempty(l)//jurge list is empty or have data
clearlist(*l)//clear the list
getelem(l,i,*e)//search the i data to return e
locateelem(l,e)//look the same data about e
listinsert(*l,i,e)//insert a data e to i
listdelete(*l,i,*e)//delete the i data,return the data
listlength(l)//return the length of the list
```

并行：将两个线性表变成交集

##### 存储结构

##### 顺序存储：地址按顺序（类似数组）

```c
struct list
{
    list[n];
    int length;
}
```

地址计算:loc(ai)=loc(a1)+(i-1)*c

存，读时间复杂度O(1);

删除，插入时间复杂度O(n);

```c
#define ok 1
#define error 0
status getelem(l,i,*e)
{
    if(l.length==0||i<1||i>l.length)
    {
        return error;
    }
    *e=l.data[i-1];
    return ok;
}
```

````c
status listinsert(*l,i,e)
{
    int k;
    if(l->length==n)//full
    {
        return error;
    }
    if(i<1||i>l->length+1)//i'location does not in the list
    {
        return error;
    }
    if(i<=l->length)
    {
     for(k=l->length-1;k>=i-1;k++)//数据后移,数组
     {
         l->data[k+1]=l->data[k];
     }
    }
    l->data[i-1]=e;
    l-<length++;
    return ok;
}
````

```c
status lsitdelete(*l,i,*e)
{
    int k;
    if(l->length==n)//full
    {
        return error;
    }
    if(i<1||i>l->length+1)//i'location does not in the list
    {
        return error;
    }
    *e=l->data[i-1];
    if(i<l->length)//数据前移
    {
        for(k=i;k<l->length;k++)
        {
            k->data[k-1]=l->data[k];
        }
    }
    l->length--;
    return ok;
}
```

##### 链式存储：地址跳跃（链表）

单链表，双向链表，多项链表

###### 单链表



```c
struct list
{
    int data;
    struct list *next;
}
```

```c
status listinsert(*l,i,e)
{
    int j;
    list p,s;
    p=*l;
    j=1;
    while(p&&j<i)//search the location
    {
        p=p->next;
        j++;
    }
    if(!p||j>i)
    {
        return error;
    }
    s=(list)malloc(sizeof(list));
    s->data=e;
    s->next=p->next;//接收下一个地址
    p->next=s;//插入s
    return ok;
}
```

````c
status listdelete(*l,i,*e)
{
    int j;
    list p,q;
    p=*l;
    j=1;
    while(p&&j<i)//search the location
    {
        p=p->next;
        j++;
    }
    if(!(p->next)||j>i)
    {
        return error;
    }
    q=p->next;//or q=p->next->next;
    p->next=1->next;
    *e=q->data;//retrun the data which was deleted
    free(q);
    return ok;
}
````

第一次插入和删除时间复杂度O(n)，后面都是O(1)

单链表对于频繁的操作效率高

头插法

```c
void creathead(*l,n)
{
    list p;
    int i;
    srand(time(0));
    *l=(list)malloc(sizeof(list));
    (*l)->next=NULL;
    for(i=0;i<n;i++)
    {
        p=(list)malloc(sizeof(list));
        p->data=rand();
        p->next=(*l)->next;
        (*l)->next=p;
    }
}
```

尾插法

```c
void creattail(*l,n)
{
    list p,r;
    int i;
    srand(time(0));
    *l=(list)malloc(sizeof(list));
    r=*l;
    for(i=0;i<n;i++)
    {
        p=(list)malloc(sizeof(list));
        p->data=rand();
        r->next=p;
        r=p;//接收上一个操作结构地址
    }
    r->next=NULL;
}
```

整表删除

```c
status clear(*l)
{
    list p,q;
    while(p)
    {
        q=p->next;
        free(p);//将整个p代表的数据加指针删除
        p=q;
    }
    (*l)->next=NULL;
    return ok;
}
```

不需要分配空间，插入和删除多时优先选择

###### 静态链表

结构体数组

```c
struct list
{
    int data;
    int cur;//游标:跳到结构体数组对应下标
}list[100];
```

```c
status creat(space)
{
    int i;
    for(i=0;i<99;i++)
    {
        speace[i].cur=i+1;
    }
    space[99].cur=0;
    return ok;
}
```

第一个和最后一个不存数据，相当于头尾结点

插入和删除

```c
int malloc_sll(space)
{
    int i=space[0].cur;
    if(space[0].cur)
    {
        space[0].cur=space[i].cur;
    }
    return i;
}
```

```c
status listinsert(l,i,e)
{
    int j,k,m;
    k=99;//the last下标
    if(i<1||i>list(l)+1)
    {
        return error;
    }
    j=malloc_sll(l);
    if(j)
    {
        l[j].data=e;
        for(m=1;m<=i-1;m++)
        {
            k=l[k].cur;
        }
        l[j].cur=l[k].cur;
        l[k].cur=j;
        return ok;
    }
    return error;
}
```

```c
status listdelete(l,i)
{
    int j,k,l;
    k=99;//the last下标
    if(i<1||i>list(l)+1)
    {
        return error;
    }
    for(j=1;j<i-1;j++)
    {
        k=l[k].cur;
    }
    j=l[k].cur;
    free_sll(l,j);
}
```

```c
void free_sll(space,k)
{
    space[k].cur=space[0].cur;
    space[0]=k;
}
```

只需要修改游标，不需要移动元素，相对于顺序存储结构更方便，培养思考方式：在没有指针的情况下

###### 寻找中间值：

链表主链双移动->next->next，副链单移动->next,注意奇偶

###### 循环链表

思路：将尾指针指向头指针（微改）

优点：可从任一结点访问整体链表

缺点：插入和删除找位置时需要找位置的循环找位比较多

寻找记得加上找一圈找不到退出的条件

解决约瑟夫环问题so easy

###### 双向链表

````c
struct list
{
    int data;
    sturct list *left;
    struct list *right;
}
````

空间换时间

### 第三节：字符串

ascll表

s="a1a2a3.......an"(n>0)，多个字符组合而成的结构

空串：无字符或""，或fai

主子串：如string是mystring的子串

字符串的比较大小：比较字符串里每个字符的ascll码大小

存储结构:顺序存储（数组），链式存储

####         BF->有回溯

找到首字符相等的位置后

两个字符串长度相等则比较每一个字符

O（M*N）

####         KMP->取消回溯，以子串为主

next：标明下一次匹配的顺序

字符无一样的：在哪里失配换回头，若是第一个则换回0

前缀：从头数，数到失配字符前的相同串    后缀：从失配字符反过来数数相同串。

前缀后缀不同填1

| T    | 4（长度） | I    | L          | O    | V    |
| ---- | --------- | ---- | ---------- | ---- | ---- |
| J    | 0         | 1    | 2          | 3    | 4    |
| K    |           | 0    | （L失配）1 |      |      |

字符有一样的：前缀后缀一个相同填2

| T    | 3    | w          | w    | .    |
| ---- | ---- | ---------- | ---- | ---- |
| J    | 0    | 1          | 2    | 3    |
| K    |      | 1（不同0） | 1    | 2    |

字符串有多个相同的串：c失配，前缀后缀数有两个相同，填3；5号失配，前缀后缀一个相同填2；

4号失配，前缀后缀无一样的填1.

| T    | 6    | b    | b    | s    | b    | b    | c    |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| J    | 0    | 1    | 2    | 3    | 4    | 5    | 6    |      |      |
| K    |      |      |      | 0    | 1    | 2    | 3    |      |      |

在b失配

| T    | 5    | s    | s    | s    | s    | b    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| J    | 0    | 1    | 2    | 3    | 4    | 5    |
| k    |      | 0    | 1    | 2    | 3    | 4    |

看串，如

| T    | 6    | a    | b    | a    | b    | a    | a    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| J    | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| K    |      | 0    | 1    | 1    | 2    | 3    | 4    |

### 第四节：栈

后进先出

push入栈

pop出栈

定义栈顶和栈底，栈长度

### 二叉树

[二叉树文件](d:\my.c\tow.c)