C51 COMPILER V9.54   USER                                                                  07/20/2023 21:58:22 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE USER
OBJECT MODULE PLACED IN .\Objects\user.obj
COMPILER INVOKED BY: D:\51project\Keil_v5\C51\BIN\C51.EXE user.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\user) DEBUG OBJECTEX
                    -TEND PRINT(.\Listings\user.lst) TABS(2) OBJECT(.\Objects\user.obj)

line level    source

   1          #include <REGX52.H>
   2          #include"delay.h"
   3          #include"HEAD.h"
   4          unsigned char Key_KeyNumber;
   5          extern unsigned char pwmfl,pwmfg,pwmbl,pwmbg,basic1;
   6          unsigned char distance;
   7          
   8          
   9          void timer()    //100微秒@11.0592MHz
  10          {
  11   1        TMOD &= 0xF0;   //设置定时器模式
  12   1        TMOD |= 0x01;   //设置定时器模式
  13   1        TL0 = 0xA4;   //设置定时初始值
  14   1        TH0 = 0xFF;   
  15   1        TF0 = 0;    //清除TF0标志
  16   1        TR0 = 1;    //定时器0开始计时
  17   1        
  18   1        ET0=1;      //1允许定时器中断
  19   1        EA=1;     //允许总中断
  20   1        PT0=0;      //中断优先级
  21   1      }
  22          
  23          void uart()
  24          {
  25   1        PCON |= 0x80;   //波特率倍速
  26   1        SCON = 0x40;    //8位数据,可变波特率,允许接收
  27   1        TMOD &= 0x0F;   //设置定时器模式
  28   1        TMOD |= 0x20;   //设置定时器模式
  29   1        TL1 = 0xF3;   //设置定时初始值
  30   1        TH1 = 0xF3;   //设置定时重载值
  31   1        ET1 = 0;    //禁止定时器ET中断，开启中断接收会增大误差
  32   1        TR1 = 1;    //定时器1开始计时
  33   1      }
  34          
  35          void sendbyte(unsigned char byte)
  36          {
  37   1        SBUF=byte;//SBUF数据接收器
  38   1        while(TI==0);//TI发送标志位，0为等待发送数据，1为发送完成
  39   1        TI=0;
  40   1      }
  41          
  42          
  43          
  44          
  45          
  46          /**
  47            * @brief  获取按键键码
  48            * @param  无
  49            * @retval 按下按键的键码，范围：0,1~4,0表示无按键按下
  50            */
  51          unsigned char Keyreturn(void)
  52          {
  53   1        unsigned char Temp=0;
  54   1        Temp=Key_KeyNumber;
C51 COMPILER V9.54   USER                                                                  07/20/2023 21:58:22 PAGE 2   

  55   1        Key_KeyNumber=0;
  56   1        return Temp;
  57   1      }
  58          
  59          /**
  60            * @brief  获取当前按键的状态，无消抖及松手检测
  61            * @param  无
  62            * @retval 按下按键的键码，范围：0,1~4,0表示无按键按下
  63            */
  64          unsigned char Key_GetState()
  65          {
  66   1        unsigned char KeyNumber=0;
  67   1        
  68   1        if(key1==0){KeyNumber=1;}
  69   1        if(key2==0){KeyNumber=2;}
  70   1        if(key3==0){KeyNumber=3;}
  71   1        if(key4==0){KeyNumber=4;}
  72   1        
  73   1        return KeyNumber;
  74   1      }
  75          
  76          /**
  77            * @brief  按键驱动函数，在中断中调用
  78            * @param  无
  79            * @retval 无
  80            */
  81          void Key_Loop(void)
  82          {
  83   1        static unsigned char NowState,LastState;
  84   1        LastState=NowState;       //按键状态更新
  85   1        NowState=Key_GetState();    //获取当前按键状态
  86   1        //如果上个时间点按键按下，这个时间点未按下，则是松手瞬间，以此避免消抖和松手检测
  87   1        if(LastState==1 && NowState==0)
  88   1        {
  89   2          Key_KeyNumber=1;
  90   2        }
  91   1        if(LastState==2 && NowState==0)
  92   1        {
  93   2          Key_KeyNumber=2;
  94   2        }
  95   1        if(LastState==3 && NowState==0)
  96   1        {
  97   2          Key_KeyNumber=3;
  98   2        }
  99   1        if(LastState==4 && NowState==0)
 100   1        {
 101   2          Key_KeyNumber=4;
 102   2        }
 103   1      }
 104          
 105          
 106          unsigned char red()
 107          {
 108   1        TMOD |= 0x11;//设置定时器模式
 109   1        TL1 = 0;//设置定时器初始值
 110   1        TH1 = 0;//设置定时器初始值
 111   1        
 112   1        TRIG = 1;
 113   1        delayus(20);//发射一段脉冲，至少20us
 114   1        TRIG = 0;
 115   1        
 116   1        while(!ECHO);//等待超声波模块返回脉冲
C51 COMPILER V9.54   USER                                                                  07/20/2023 21:58:22 PAGE 3   

 117   1        TR1=1;//打开定时器
 118   1        while(ECHO);//等待超声波定时器返回脉冲结束
 119   1        TR1 = 0;//停止计数器，计时结束
 120   1        
 121   1        distance=((TH1*256+TL1)*0.034)/2+1;//计算距离,定时器1的计数器，12t为1us一个计数，故总时间为那么多
 122   1        
 123   1        return distance;
 124   1      }
 125          
 126          void forward()
 127          {
 128   1        blf=1;
 129   1        blb=0;
 130   1        bgf=1;
 131   1        bgb=0;
 132   1        flf=1;
 133   1        flb=0;
 134   1        fgf=1;
 135   1        fgb=0;
 136   1      }
 137          
 138          void backward()
 139          {
 140   1        blf=0;
 141   1        blb=1;
 142   1        bgf=0;
 143   1        bgb=1;
 144   1        flf=0;
 145   1        flb=1;
 146   1        fgf=0;
 147   1        fgb=1;
 148   1      }
 149          
 150          void stop()
 151          {
 152   1        blf=0;
 153   1        blb=0;
 154   1        bgf=0;
 155   1        bgb=0;
 156   1        flf=0;
 157   1        flb=0;
 158   1        fgf=0;
 159   1        fgb=0;
 160   1      }
 161          
 162          void reward()
 163          {pwmfl=pwmfg=pwmbl=pwmbg=basic1;}
 164          
 165          void tlf()//左前转
 166          {
 167   1        forward();
 168   1        pwmfl=255;
 169   1        pwmbl=255;
 170   1        pwmbg=100;
 171   1        pwmfg=pwmbg+20;
 172   1      
 173   1      }
 174          
 175          void tgf()
 176          {
 177   1        forward();
 178   1        pwmfg=255;
C51 COMPILER V9.54   USER                                                                  07/20/2023 21:58:22 PAGE 4   

 179   1        pwmbg=255;
 180   1        pwmbl=100;
 181   1        pwmfl=pwmbl+20;
 182   1      
 183   1      }
 184          
 185          void tlb()
 186          {
 187   1        backward();
 188   1        pwmfl=255;
 189   1        pwmbl=255;
 190   1        pwmfg=100;
 191   1        pwmbg=pwmfg+20;
 192   1      
 193   1      }
 194          
 195          void tgb()
 196          {
 197   1        backward();
 198   1        pwmfg=255;
 199   1        pwmbg=255;
 200   1        pwmbl=100;
 201   1        pwmfl=pwmbl+20;
 202   1      
 203   1      }
 204          void look_road()
 205          {
 206   1        if(clx){tgf();}
 207   1        if(crx){tlf();}
 208   1        if(mlx&&clx){tgf();}
 209   1        if(mrx&&crx){tlf();}
 210   1        if(clx==0&&crx==0&&mlx==0&&mrx==0){reward();}
 211   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    405    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
