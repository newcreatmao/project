C51 COMPILER V9.54   MAIN                                                                  05/29/2024 13:29:19 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\51project\Keil_v5\keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2
                    -)

line level    source

   1          ///*************************************************************/
   2          ///********************* 24 矩阵键盘读取实验 *******************/
   3          ///*************************************************************/
   4          ///************************* 作者：XHCH ************************/
   5          ///*************************************************************/
   6          ///******************* 修改日期：2012年2月3日 ******************/
   7          ///*************************************************************/
   8          ///***************************************************************************
   9          //实验名称： 矩阵键盘读取实验
  10          
  11          //实验模块:  51单片机核心板、矩阵键盘区、液晶显示区（1602）
  12          
  13          //实验接线：  51单片机核心板------矩阵键盘区
  14          //        P1.0~P1.3 --------- ROW1~ROW4
  15          //        P1.4~P1.7 --------- LINE1~LINE4       
  16          //          
  17          //      51单片机核心板------液晶显示区（1602字符液晶）
  18          //          P2.0 --------- RS
  19          //          P2.1 --------- RW
  20          //          P2.2 --------- E
  21          //         P0.0~P0.7 --------- BD0~BD7    
  22          //            
  23          //现象描述：  1602液晶屏上排显示按键的位码，下排显示按键所表示的字符
  24          
  25          //更新时间：  2017.10.17
  26          //***************************************************************************/
  27          
  28          //#include <reg52.h>               
  29          
  30          //unsigned char  dis_buf;       //显示缓存
  31          //unsigned char  temp;
  32          //unsigned char  key=0;         //键顺序码
  33          
  34          //sbit  LCM_RS = P2^0;      //定义引脚
  35          //sbit  LCM_RW = P2^1;
  36          //sbit  LCM_E  = P2^2;
  37          
  38          //#define LCM_Data P0
  39          //#define Busy 0x80 //用于检测LCM状态字中的Busy标识
  40          
  41          //unsigned char code  cdis1[ ] = {"KEY NUMBER:   H "};
  42          //unsigned char code  cdis2[ ] = {"  KEY-CODE:   H "};
  43          //unsigned char Code[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
  44          
  45          ///**********************************************************/
  46          ///*******************LCM1602相关函数************************/
  47          ///**********************************************************/
  48          ////读状态
  49          //unsigned char ReadStatusLCM(void)
  50          //{
  51          //    LCM_Data = 0xFF; 
  52          //    LCM_RS = 0;
  53          //    LCM_RW = 1;
  54          //    LCM_E = 0;
C51 COMPILER V9.54   MAIN                                                                  05/29/2024 13:29:19 PAGE 2   

  55          //    LCM_E = 0;
  56          //    LCM_E = 1;
  57          //    while (LCM_Data & Busy); //检测忙信号
  58          //    return(LCM_Data);
  59          //    LCM_E = 0;
  60          //}
  61          
  62          
  63          ///**********************************************************/
  64          ////5ms延时
  65          //void Delay5Ms(void)
  66          //{
  67          //    unsigned int TempCyc = 5552;
  68          //    while(TempCyc--);
  69          //}
  70          
  71          ///**********************************************************/
  72          ////写数据
  73          //void WriteDataLCM(unsigned char WDLCM)
  74          //{
  75          //    ReadStatusLCM(); //检测忙
  76          //    LCM_Data = WDLCM;
  77          //    LCM_RS = 1;
  78          //    LCM_RW = 0;
  79          //    LCM_E = 0; //若晶振速度太高可以在这后加小的延时
  80          //    LCM_E = 0; //延时
  81          //    LCM_E = 1;
  82          //    LCM_E = 0;
  83          //}
  84          
  85          ///**********************************************************/
  86          ////写指令
  87          //void WriteCommandLCM(unsigned char WCLCM,BuysC) //BuysC为0时忽略忙检测
  88          //{
  89          //    if (BuysC) ReadStatusLCM(); //根据需要检测忙
  90          //    LCM_Data = WCLCM;
  91          //    LCM_RS = 0;
  92          //    LCM_RW = 0; 
  93          //    LCM_E = 0;
  94          //    LCM_E = 0;
  95          //    LCM_E = 1; 
  96          //    LCM_E = 0;
  97          //}
  98          
  99          ///**********************************************************/
 100          ////读数据
 101          //unsigned char ReadDataLCM(void)
 102          //{
 103          //    LCM_RS = 1; 
 104          //    LCM_RW = 1;
 105          //    LCM_E = 0;
 106          //    LCM_E = 0;
 107          //    LCM_E = 1;
 108          //    return(LCM_Data);
 109          //    LCM_E = 0;
 110          //}
 111          
 112          ///**********************************************************/
 113          ////LCM初始化
 114          //void LCMInit(void) 
 115          //{
 116          //    LCM_Data = 0;
C51 COMPILER V9.54   MAIN                                                                  05/29/2024 13:29:19 PAGE 3   

 117          //    WriteCommandLCM(0x38,0); //三次显示模式设置，不检测忙信号
 118          //    Delay5Ms(); 
 119          //    WriteCommandLCM(0x38,0);
 120          //    Delay5Ms(); 
 121          //    WriteCommandLCM(0x38,0);
 122          //    Delay5Ms(); 
 123          
 124          //    WriteCommandLCM(0x38,1); //显示模式设置,开始要求每次检测忙信号
 125          //    WriteCommandLCM(0x08,1); //关闭显示
 126          //    WriteCommandLCM(0x01,1); //显示清屏
 127          //    WriteCommandLCM(0x06,1); //显示光标移动设置
 128          //    WriteCommandLCM(0x0C,1); //显示开及光标设置
 129          //}
 130          
 131          ///**********************************************************/
 132          ////按指定位置显示一个字符
 133          //void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)
 134          //{
 135          //    Y &= 0x1;
 136          //    X &= 0xF;             //限制X不能大于15，Y不能大于1
 137          //    if (Y) X |= 0x40;     //当要显示第二行时地址码+0x40;
 138          //    X |= 0x80;            //算出指令码
 139          //    WriteCommandLCM(X, 0);  //这里不检测忙信号，发送地址码
 140          //    WriteDataLCM(DData);
 141          //}
 142          
 143          ///**********************************************************/
 144          //// 键扫描子程序
 145          //void  keyscan(void)
 146          // { 
 147          //    P1=0xF0;                //行线为输入，列线为输出，并置列线输出全为0
 148          //   temp=P1;               //读P1口       
 149          //    temp=temp&0xF0;
 150          //    temp=~((temp>>4)|0xF0);
 151          //    if(temp==1)
 152          //        key=0;
 153          //    else if(temp==2)
 154          //        key=1;
 155          //    else if(temp==4)
 156          //        key=2;
 157          //    else if(temp==8)
 158          //        key=3;
 159          //    P1=0x0F;                 //列线为输入，行线为输出，并置行线输出全为0  
 160          //   temp=P1;                //读P1口 
 161          //    temp=temp&0x0F;
 162          //    temp=~(temp|0xF0);        
 163          //    if(temp==1)
 164          //        key=key+0;
 165          //    else if(temp==2)
 166          //        key=key+4;
 167          //    else if(temp==4)
 168          //        key=key+8;
 169          //    else if(temp==8)
 170          //        key=key+12;
 171          //      
 172          //     dis_buf = key;              //键值入显示缓存
 173          //     dis_buf = dis_buf&0x0f;
 174          
 175          //   if(dis_buf>9)               //转换为ASCII码
 176          //      dis_buf = dis_buf+0x37;
 177          //    else
 178          //     dis_buf = dis_buf+0x30;
C51 COMPILER V9.54   MAIN                                                                  05/29/2024 13:29:19 PAGE 4   

 179          // }
 180          
 181          ///*************************************************************/
 182          ////判断键是否按下
 183          //void  keydown(void)
 184          // {  
 185          //    P1=0xF0;
 186          //   Delay5Ms();
 187          //  if(P1!=0xF0)
 188          //  {
 189          //    keyscan();
 190          //    }
 191          // }
 192          
 193          /*************************************************************/
 194          // 主程序
 195          
 196          
 197          /************************************************************/  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
